{
  "name": "rewire",
  "version": "2.1.0",
  "description": "Easy dependency injection for node.js unit testing",
  "keywords": [
    "dependency",
    "injection",
    "mock",
    "shim",
    "module",
    "unit",
    "test",
    "leak",
    "inspect"
  ],
  "author": {
    "name": "Johannes Ewald",
    "email": "mail@johannesewald.de"
  },
  "main": "lib/index.js",
  "homepage": "https://github.com/jhnns/rewire",
  "bugs": {
    "url": "https://github.com/jhnns/rewire/issues",
    "email": "mail@johannesewald.de"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jhnns/rewire.git"
  },
  "devDependencies": {
    "mocha": "1.x",
    "expect.js": "0.x",
    "coffee-script": "1.x"
  },
  "scripts": {
    "test": "node node_modules/mocha/bin/mocha -R spec",
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha"
  },
  "readme": "rewire\r\n=====\r\n**Easy dependency injection for node.js unit testing**.\r\n\r\n[![Build Status](https://travis-ci.org/jhnns/rewire.svg?branch=master)](http://travis-ci.org/jhnns/rewire)\r\n[![Dependency Status](https://david-dm.org/jhnns/rewire.svg)](https://david-dm.org/jhnns/rewire)\r\n[![Coverage Status](https://img.shields.io/coveralls/jhnns/rewire.svg)](https://coveralls.io/r/jhnns/rewire)\r\n[![Gittip Donate Button](http://img.shields.io/gittip/peerigon.svg)](https://www.gittip.com/peerigon/)\r\n\r\nrewire adds a special setter and getter to modules so you can modify their behaviour for better unit testing. You may\r\n\r\n- inject mocks for other modules or globals like `process`\r\n- leak private variables\r\n- override variables within the module.\r\n\r\nrewire does **not** load the file and eval the contents to emulate node's require mechanism. In fact it uses node's own\r\nrequire to load the module. Thus your module behaves exactly the same in your test environment as under regular\r\ncircumstances (except your modifications).\r\n\r\nGood news to all caffeine-addicts: rewire works also with [Coffee-Script](http://coffeescript.org/). Note that in this\r\ncase CoffeeScript needs to be listed in your devDependencies.\r\n\r\nIf you want to use rewire also on the client-side take a look at [client-side bundlers](https://github.com/jhnns/rewire#client-side-bundlers)\r\n\r\n[![npm status](https://nodei.co/npm/rewire.svg?downloads=true&stars=true)](https://npmjs.org/package/rewire)\r\n\r\n<br />\r\n\r\nIntroduction\r\n--------\r\n\r\nImagine you want to test this module:\r\n\r\n`lib/myModule.js`\r\n```javascript\r\n// With rewire you can change all these variables\r\nvar fs = require(\"fs\"),\r\n    path = \"/somewhere/on/the/disk\";\r\n\r\nfunction readSomethingFromFileSystem(cb) {\r\n    console.log(\"Reading from file system ...\");\r\n    fs.readFile(path, \"utf8\", cb);\r\n}\r\n\r\nexports.readSomethingFromFileSystem = readSomethingFromFileSystem;\r\n```\r\n\r\nNow within your test module:\r\n\r\n`test/myModule.test.js`\r\n```javascript\r\nvar rewire = require(\"rewire\");\r\n\r\nvar myModule = rewire(\"../lib/myModule.js\");\r\n```\r\n\r\nrewire acts exactly like require. Just with one difference: Your module will now export a special setter and getter for private variables.\r\n\r\n```javascript\r\nmyModule.__set__(\"path\", \"/dev/null\");\r\nmyModule.__get__(\"path\"); // = '/dev/null'\r\n```\r\n\r\nThis allows you to mock everything in the top-level scope of the module, like the fs module for example. Just pass the variable name as first parameter and your mock as second.\r\n\r\n```javascript\r\nvar fsMock = {\r\n    readFile: function (path, encoding, cb) {\r\n        expect(path).to.equal(\"/somewhere/on/the/disk\");\r\n        cb(null, \"Success!\");\r\n    }\r\n};\r\nmyModule.__set__(\"fs\", fsMock);\r\n\r\nmyModule.readSomethingFromFileSystem(function (err, data) {\r\n    console.log(data); // = Success!\r\n});\r\n```\r\n\r\nYou can also set multiple variables with one call.\r\n\r\n```javascript\r\nmyModule.__set__({\r\n    fs: fsMock,\r\n    path: \"/dev/null\"\r\n});\r\n```\r\n\r\nYou may also override globals. These changes are only within the module, so you don't have to be concerned that other modules are influenced by your mock.\r\n\r\n```javascript\r\nmyModule.__set__({\r\n    console: {\r\n        log: function () { /* be quiet */ }\r\n    },\r\n    process: {\r\n        argv: [\"testArg1\", \"testArg2\"]\r\n    }\r\n});\r\n```\r\n\r\n`__set__` returns a function which reverts the changes introduced by this particular `__set__` call\r\n\r\n```javascript\r\nvar revert = myModule.__set__(\"port\", 3000);\r\n\r\n// port is now 3000\r\nrevert();\r\n// port is now the previous value \r\n```\r\n\r\nFor your convenience you can also use the `__with__` method which reverts the given changes after it finished.\r\n\r\n```javascript\r\nmyModule.__with__({\r\n    port: 3000\r\n})(function () {\r\n    // within this function port is 3000\r\n});\r\n// now port is the previous value again\r\n```\r\n\r\nThe `__with__` method is also aware of promises. If a thenable is returned all changes stay until the promise has either been resolved or rejected.\r\n\r\n```javascript\r\nmyModule.__with__({\r\n    port: 3000\r\n})(function () {\r\n    return new Promise(...);\r\n}).then(function () {\r\n    // now port is the previous value again\r\n});\r\n// port is still 3000 here because the promise hasn't been resolved yet\r\n```\r\n\r\n### Caveats\r\n\r\n**Difference to require()**<br>\r\nEvery call of rewire() executes the module again and returns a fresh instance.\r\n\r\n```javascript \r\nrewire(\"./myModule.js\") === rewire(\"./myModule.js\"); // = false\r\n```\r\n\r\nThis can especially be a problem if the module is not idempotent [like mongoose models](https://github.com/jhnns/rewire/issues/27).\r\n\r\n**Changing globals**<br>\r\nBe careful, if you do something like this you'll change your global console instance.\r\n\r\n```javascript\r\nmyModule.__set__(\"console.log\", function () { /* be quiet */ });\r\n```\r\n\r\n<br />\r\n\r\nAPI\r\n------\r\n\r\n### rewire(filename: String): rewiredModule\r\n\r\nReturns a rewired version of the module found at `filename`. Use `rewire()` exactly like `require()`. \r\n\r\n### rewiredModule.&#95;&#95;set&#95;&#95;(name: String, value: *): Function\r\n\r\nSets the internal variable `name` to the given `value`. Returns a function which can be called to revert the change.\r\n\r\n### rewiredModule.&#95;&#95;set&#95;&#95;(obj: Object): Function\r\n\r\nTakes all enumerable keys of `obj` as variable names and sets the values respectively. Returns a function which can be called to revert the change.\r\n\r\n### rewiredModule.&#95;&#95;get&#95;&#95;(name: String): *\r\n\r\nReturns the private variable with the given `name`.\r\n\r\n### rewiredModule.&#95;&#95;with&#95;&#95;(obj: Object): Function&lt;callback: Function>\r\n\r\nReturns a function which - when being called - sets `obj`, executes the given `callback` and reverts `obj`. If `callback` returns a promise, `obj` is only reverted after the promise has been resolved or rejected. For your convenience the returned function passes the received promise through.\r\n\r\n<br />\r\n\r\n##Client-Side Bundlers\r\n\r\n###webpack\r\nSee [rewire-webpack](https://github.com/jhnns/rewire-webpack)\r\n\r\n###browserify\r\nIf you're using browserify and want to use rewire with browserify [please let me know](https://github.com/jhnns/rewire/issues/13).\r\n\r\n<br />\r\n\r\n##License\r\n\r\nMIT\r\n",
  "readmeFilename": "README.md",
  "_id": "rewire@2.1.0",
  "_from": "rewire@*"
}
