var fmt = require('util').format;
var jwt = require('jwt-simple');

module.exports = License;

License.defaultSecret = 'strong-license';
License.defaultAlgorithm = 'HS256';

/**
 * License extends the JWT (JSON Web Token) format by adding additional fields,
 * defining a wildcard semantic for some fields, defining semantics for
 * validation against a query.
 * @class
 * @param {(string|Object)} input Encoded license string or license description object
 * @param {string} [secret] Secret to use for encoding/decoding the license
 * @param {string} [algorithm] Algorithm to encode/decode with
 */
function License(input, secret, algorithm) {
  if (!(this instanceof License))
    return new License(key);

  secret = secret || License.defaultSecret;
  algorithm = algorithm || License.defaultAlgorithm;

  if (typeof input === 'string' || input instanceof String) {
    this.key = input;
    this.details = normalized(safeDecode(input, secret));
  } else {
    input = input || {};
    this.details = normalized(input);
    this.key = jwt.encode(this.details, secret, algorithm);
  }
}

License.prototype.export = function LicenseExport(secret, algorithm) {
  secret = secret || License.defaultSecret;
  algorithm = algorithm || License.defaultAlgorithm;
  return jwt.encode(this.details, secret, algorithm);
};

/**
 * @returns {Object} decoded object to stringify when serializing to JSON
 */
License.prototype.toJSON = function LicenseToJSON() {
  return this.details;
};

/**
 * @returns {string} decoded single-line string representation of a License
 */
License.prototype.toString = function LicenseToString() {
  var lic = this.details;
  return fmt('License(email: %s, prod: %s, feat: %s, start: %s, end: %s)',
             lic.email, lic.product, lic.features.join(','),
             lic.activationDate, lic.expirationDate);
};

/**
 * Licenses define a combination of product and features and the period of
 * time that the product and features are licensed for.
 * Parameters that are not given (or are otherwise falsey) do not have
 * requirements, so they always pass. If no arguments are given, then all
 * of the requirements are met and the scenario is considered "covered".
 * @param {string} [product] Product string to query license for
 * @param {string} [features] Feature string to query license for
 * @param {Date} [when] Point in time to test license against
 * @returns {Boolean} Whether the license covers the specified product,
 *                    feature, and time.
 */
License.prototype.covers = function LicenseCovers(product, feature, when) {
  return (this.coversProduct(product)
          && this.coversFeature(feature)
          && this.coversDate(when));
};

/**
 * @param {string} [query] product string to test for
 * @returns {Boolean} true if query is falsey, identical to the product string
 *                    in the license, or if the product in the license is '*'.
 */
License.prototype.coversProduct = function LicenseCoversProduct(query) {
  return match(this.details.product, query);
};

/**
 * @param {string} [query] feature string to test for
 * @returns {Boolean} true if query is falsey, identical any string in the
 *                    license's feature list, or if the license's feature list
 *                    contains a '*'.
 */
License.prototype.coversFeature = function LicenseCoversFeature(query) {
  return !query || this.details.features.some(function(enabled) {
    return match(enabled, query);
  });
};

/**
 * @param {Date} [when] point in time to test activation/expiration against
 * @returns {Boolean} true if when is falsey, or if it is between the
 *                    activationDate and expirationDate in the license.
 */
License.prototype.coversDate = function LicenseCoversDate(when) {
  var lic = this.details;
  return !when || (lic.activationDate < when && lic.expirationDate > when);
};

// 'foo' matches 'foo'
// * matches anything
// falsey query is matched by anything
function match(pattern, query) {
  var result = !query || pattern === '*' || pattern === query;
  return result;
}

// Normalize input fields, defaulting to "invalid" or "expired" state where
// details are missing.
function normalized(input) {
  var l = JSON.parse(JSON.stringify(input));
  l.userId = l.userId || null;
  l.email = l.email || null;
  l.product = l.product || null;
  if (l.product !== null) {
    l.product = String(l.product);
  }
  l.features = l.features || [];
  if (typeof l.features === 'string') {
    // split on , and :
    l.features = l.features.split(/(?:,|:)/);
  } else if (!Array.isArray(l.features)) {
    l.features = [];
  }
  if (l.feature) {
    l.features.push(l.feature)
  }
  l.features = l.features.map(function(f) {
    return f.trim();
  }).filter(function(f) {
    return !!f;
  });
  l.activationDate = new Date(l.activationDate || 0);
  l.expirationDate = new Date(l.expirationDate || 0);
  return l;
}

function safeDecode(input, secret, algorithm) {
  try {
    return normalized(jwt.decode(input, secret, algorithm));
  } catch (e) {
    return normalized({});
  }
}

// If run directly, parse each argument as a license and dump its contents
if (module === require.main) {
  process.argv.slice(2).forEach(function(k) {
    console.log('%j', new License(k));
  });
}
