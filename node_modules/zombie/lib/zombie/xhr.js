// Generated by CoffeeScript 1.6.3
var Events, HTML, URL, XMLHttpRequest, raise,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

HTML = require("jsdom").dom.level3.html;

Events = require("jsdom").dom.level3.events;

URL = require("url");

raise = require("./scripts");

HTML.SECURITY_ERR = 18;

HTML.NETWORK_ERR = 19;

HTML.ABORT_ERR = 20;

XMLHttpRequest = (function(_super) {
  __extends(XMLHttpRequest, _super);

  function XMLHttpRequest(window) {
    this._window = window;
    this._pending = [];
    this._responseHeaders = null;
    this.onreadystatechange = null;
    this.timeout = 0;
    this.status = null;
    this.statusText = null;
    this.responseText = null;
    this.responseXML = null;
    this._ownerDocument = window.document;
    this._parentNode = window;
  }

  XMLHttpRequest.prototype.abort = function() {
    var request, _i, _len, _ref;
    _ref = this._pending;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      request = _ref[_i];
      request.error || (request.error = new HTML.DOMException(HTML.ABORT_ERR, "Request aborted"));
    }
    return this.readyState = XMLHttpRequest.UNSENT;
  };

  XMLHttpRequest.prototype.getAllResponseHeaders = function(header) {
    var headerStrings, value, _ref;
    if (this._responseHeaders) {
      headerStrings = [];
      _ref = this._responseHeaders;
      for (header in _ref) {
        value = _ref[header];
        headerStrings.push("" + header + ": " + value);
      }
      return headerStrings.join("\n");
    } else {
      return null;
    }
  };

  XMLHttpRequest.prototype.getResponseHeader = function(header) {
    if (this._responseHeaders) {
      return this._responseHeaders[header.toLowerCase()];
    } else {
      return null;
    }
  };

  XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
    var headers, request;
    if (async === false) {
      throw new HTML.DOMException(HTML.NOT_SUPPORTED_ERR, "Zombie does not support synchronous XHR requests");
    }
    this.abort();
    method = method.toUpperCase();
    if (/^(CONNECT|TRACE|TRACK)$/.test(method)) {
      throw new HTML.DOMException(HTML.SECURITY_ERR, "Unsupported HTTP method");
    }
    if (!/^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/.test(method)) {
      throw new HTML.DOMException(HTML.SYNTAX_ERR, "Unsupported HTTP method");
    }
    headers = {};
    url = URL.parse(URL.resolve(this._window.location.href, url));
    if ((url.protocol === 'https:' && url.port === '443') || (url.protocol === 'http:' && url.port === '80')) {
      delete url.port;
    }
    if (!/^https?:$/i.test(url.protocol)) {
      throw new HTML.DOMException(HTML.NOT_SUPPORTED_ERR, "Only HTTP/S protocol supported");
    }
    url.hostname || (url.hostname = this._window.location.hostname);
    url.host = url.port ? url.host = "" + url.hostname + ":" + url.port : url.host = url.hostname;
    if (url.host !== this._window.location.host) {
      headers.origin = this._window.location.protocol + "//" + this._window.location.host;
      this._cors = headers.origin;
    }
    url.hash = null;
    if (user) {
      url.auth = "" + user + ":" + password;
    }
    this.status = null;
    this.statusText = null;
    this.responseText = null;
    this.responseXML = null;
    request = {
      method: method,
      url: URL.format(url),
      headers: headers
    };
    this._pending.push(request);
    this._stateChanged(XMLHttpRequest.OPENED);
  };

  XMLHttpRequest.prototype.send = function(data) {
    var request, _base,
      _this = this;
    if (this.readyState !== XMLHttpRequest.OPENED) {
      throw new HTML.DOMException(HTML.INVALID_STATE_ERR, "Invalid state");
    }
    request = this._pending[this._pending.length - 1];
    (_base = request.headers)["content-type"] || (_base["content-type"] = "text/plain");
    request.body = data;
    request.timeout = this.timeout;
    this._window._eventQueue.http(request.method, request.url, request, function(error, response) {
      var allowedOrigin, event;
      error || (error = request.error);
      if (error) {
        event = new Events.Event('xhr');
        event.initEvent('error', true, true);
        event.error = new HTML.DOMException(HTML.NETWORK_ERR, error.message);
        _this.dispatchEvent(event);
        return;
      }
      if (_this._cors) {
        allowedOrigin = response.headers['access-control-allow-origin'];
        if (!(allowedOrigin === '*' || allowedOrigin === _this._cors)) {
          event = new Events.Event('xhr');
          event.initEvent('error', true, true);
          event.error = new HTML.DOMException(HTML.SECURITY_ERR, "Cannot make request to different domain");
          _this.dispatchEvent(event);
          return;
        }
      }
      _this.status = response.statusCode;
      _this.statusText = response.statusText;
      _this._responseHeaders = response.headers;
      _this._stateChanged(XMLHttpRequest.HEADERS_RECEIVED);
      return _this._window._eventQueue.enqueue(function() {
        var _ref;
        _this.responseText = ((_ref = response.body) != null ? _ref.toString() : void 0) || "";
        _this.responseXML = null;
        return _this._stateChanged(XMLHttpRequest.DONE);
      });
    });
  };

  XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
    var request;
    if (this.readyState !== XMLHttpRequest.OPENED) {
      throw new HTML.DOMException(HTML.INVALID_STATE_ERR, "Invalid state");
    }
    request = this._pending[this._pending.length - 1];
    request.headers[header.toString().toLowerCase()] = value.toString();
  };

  XMLHttpRequest.prototype._stateChanged = function(newState) {
    var event,
      _this = this;
    this.readyState = newState;
    if (newState === XMLHttpRequest.DONE) {
      event = new Events.Event('xhr');
      event.initEvent('load', false, true);
      this.dispatchEvent(event);
    }
    if (this.onreadystatechange) {
      return this._window._eventQueue.enqueue(function() {
        var error;
        try {
          return _this.onreadystatechange.call(_this);
        } catch (_error) {
          error = _error;
          return raise({
            element: _this._window.document,
            from: __filename,
            scope: "XHR",
            error: error
          });
        }
      });
    }
  };

  return XMLHttpRequest;

})(Events.EventTarget);

XMLHttpRequest.UNSENT = 0;

XMLHttpRequest.OPENED = 1;

XMLHttpRequest.HEADERS_RECEIVED = 2;

XMLHttpRequest.LOADING = 3;

XMLHttpRequest.DONE = 4;

module.exports = XMLHttpRequest;
